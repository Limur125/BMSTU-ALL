\chapter{Аналитический раздел}

В данном разделе формализованы объект и его признак, описаны структура данных словарь, алгоритм поиска подстроки в строке и алгоритм поиска по словарю

\section{Постановка задачи поиска в словаре}

В рамках данной лабораторной работы требуется разработать метод поиска по словарю при ограничении на значение признака, заданном при помощи лингвистической переменной. 

Написать программу, которая по словарю <объект, числовое значение его единственного признака> и по пользовательскому запросу в виде строки, содержащей вопрос на ограниченном естественном языке (русском языке) с ограничением на признак, заданный лингвистической переменой , выдаст релевантные запросу объекты из словаря либо сообщение, что вопрос не распознан либо не соответствует выбранной тематике.

Результат: прототип диалоговой системы, обладающей функциональностью ответа на вопросы на ограниченном естественном языке посвященные выборке объектов согласно тематике и содержащие указанные на искомый объект на его признак --- лингвистическую переменную.

Требования к функциональности программы:
\begin{itemize}[label=---]
\item программа на вход получает вопрос, имеющий целью запрос на поиск в словаре;
	
\item программа выводит список названий видео с количеством просмотров.
\end{itemize}

Для поиска потребуется структура данных словаря, алгоритм поиска в нём и поиска подстроки в строке.

Далее будут формализованы объект и его признак, будут описаны типовые вопросы.

\section{Формализация объекта и его признака}

В качестве объекта для словаря была выбрана статистика по просмотрам видео на YouTube. 

Признак $p$ --- число просмотров видео.

$T$ --- множество термов \eqref{eq:term}.
\begin{equation}
	\label{eq:term}
	\begin{array}{cc}
		T = \{\text{~очень маленькое, не очень маленькое, маленькое,}\\ \text{ небольшое, среднее, немаленькое, не очень большое,}\\ \text{большое, очень большое, невероятно большое~}\}
	\end{array}
\end{equation}.

$X$ --- множество значений \eqref{eq:znach}. 
\begin{equation}
	\label{eq:znach}
	\begin{array}{cc}
		X = \{\text{~0, 10 тыс, 50 тыс, 100 тыс, 200 тыс,} \\ \text{500 тыс, 1 	млн, 10 млн, 100 млн, 200 млн~}\}
	\end{array}
\end{equation}

$\mu_i$ --- степень принадлежности $x_j \in X$ значения терму $t_i \in T$:

\begin{equation}
	\label{eq:mu}
	\mu_i(x_j) = \frac{\sum_{k=1}^{K}a^k_{ij}}{K},
\end{equation}
где $k$ --- идентификатор респондента,
$K$ --- количество респондентов,\\ $a_{ij}^k$ --- голос $k$ респондента за то, что $j$ значение принадлежит $i$ терму.

Типовой вопрос должен содержать одно из слов <<Найди>>, <<Какие>>, <<Покажи>>, <<Поищи>> --- слово, обозначающее что вопрос имеет целью запрос на поиск в словаре. Вопрос должен содержать слово <<видео>> или <<видос>>, как слово указывающее на объект поиска. В вопросе должно присутствовать условие фильтрации (лингвистическая переменная), а также должен быть указан критерий поиска (<<популярность>>, <<просмотры>>, <<посмотрело <переменная> количество людей>>). В вопросе должен соблюдаться порядок слов.

\section{Алгоритм поиска подстроки строке}

Часто приходится сталкиваться со специфическим поиском, так называемым поиском подстроки в строке~\cite{subsearch}. Его можно определить следующим образом. 

Пусть задана строка $S$ из $N$ элементов и строка $P$ из $M$ элементов. Описаны они так: $string S[N], P[M]$;

Задача поиска подстроки P в строке S заключается в нахождении первого слева вхождения $P$ в $S$, т.е. поиск значения индекса $i$, начиная с которого выполняются условия~\eqref{eq1}

\begin{equation}\label{eq1}
	\begin{array}{cc}
		S[i] = P[0] \\
		S[i + 1] = P[1] \\
		\ldots \\
		S[i + M - 1] = P[M - 1]
	\end{array}
\end{equation}

Алгоритм прямого поиска подстроки в строке
\begin{enumerate}
	\item Установить $i$ на начало строки $S$, т.е. $i = 0$.
	\item Проверить, не вышло ли $i + M$ за границу $N$ строки $S$. Если да, то алгоритм завершен (вхождения нет).
	\item Начиная с $i$-го символа $S$ провести посимвольное сравнение строк $S$ и $P$, т. е. проверить условия~\eqref{eq1}.
	\item Если хотя бы одна пара символов не совпала, то увеличить $i$ и повторить шаг 2, иначе 
	алгоритм завершен (вхождение найдено).
\end{enumerate}

\section{Словарь}

Для доступа к элементам индексного массива используются обычные целые числа, называемые индексами~\cite{dictionary}. У ассоциативного массива (словаря) эту функцию выполняют ключи. Они, в отличие от индексов, могут быть заданы не только числовым типом данных, но и, например строковым или булевым. Каждому элементу ассоциативного массива соответствует пара «ключ-значение» (key, value), и на нем определены четыре базовые операции:
\begin{itemize}
\item INSERT --- операция добавления пары в массив;
\item REASSIGN --- операция изменения существующей пары;
\item DELETE --- операция удаления пары из массива;
\item SEARCH --- операция поиска пары в массиве.
\end{itemize}
Данный список является стандартным, но все же он может быть дополнен некоторыми другими операциями. Также стоит отметить, что здесь приведены не общепринятые названия операций: обычно они зависят от языка программирования, на котором реализуются, да и вообще термин, обозначающий ассоциативный массив, варьируется в зависимости все от того же языка. 

\section{Алгоритм поиска по словарю}

Алгоритм полного перебора сводится к последовательному прохождению по всем ключам словаря и их сравнению с заданным ключом. 

Этот алгоритм считается методом <<грубой силы>>~\cite{kekw}. Зато он может производиться в неотсортированном словаре, а добавление новых элементов в такой словарь не вызывает затруднений -- их можно добавлять на любую позицию. Дополнительных затрат по памяти также не требуется.

\section*{Вывод}

В данном разделе были формализованы объект и его признак, были описаны структура данных словарь, алгоритм поиска подстроки в строке и алгоритм поиска по словарю.
