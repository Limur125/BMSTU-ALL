\chapter{Исследовательская часть}

В данном разделе будут приведены примеры работы программ, постановка эксперимента и сравнительный анализ алгоритмов на основе полученных данных.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось исследование:

\begin{itemize}
	\item операционная система Windows 10 Корпоративная, Версия	21H1, Сборка ОС 19043.2006;
	\item память 8 ГБ;
	\item процессор AMD Ryzen 5 4600H с видеокартой Radeon Graphics 3.00 ГГц \cite{processor}.
\end{itemize}

Исследование проводилось на ноутбуке, включенном в сеть электропитания. Во время исследования ноутбук был нагружен только встроенными приложениями окружения, а также непосредственно системой.

\section{Демонстрация работы программы}

На рис. \ref{fig:--2022-09-25-195051} приведен пример работы программы: пользователь выбрал первый пункт меню -- расчёт расстояния Левенштейна -- и ввёл две строки. Отображено результирующее расстояние, а также матрица промежуточных расстояний между подстроками, поскольку выбранный алгоритм расчёта основан на заполнении матрицы по рекуррентной формуле (\ref{eq:D}).
\begin{figure}[H]
	\centering
	\includegraphics[width=01\linewidth]{"inc/img/Снимок экрана 2022-09-25 195051"}
	\caption{Демонстрация работы программы}
	\label{fig:--2022-09-25-195051}
\end{figure}

\section{Время выполнения реализаций алгоритмов}

%Алгоритмы тестировались 
Замеры процессорного времени выполнения реализаций алгоритмов выполнены 
при помощи функции clock() \cite{cpplangtime}. Данная функция всегда возвращает значения времени, а именно сумму системного и пользовательского процессорного времени текущего процессора, типа float в тиках.

Замеры времени для каждой длины слов проводились 100 раз. Длины строк совпадают. В качестве результата взято среднее время работы алгоритма на данной длине слова.

Результаты замеров приведены в таблицах \ref{tab:time}--\ref{tab:time2} (время в тиках) и на рис. \ref{fig:--2022-09-25-200448}.

\begin{table}[H]
	\begin{center}
		\caption{\label{tab:time}Результаты замеров времени}
		\begin{tabular}{|c|c|c|c|c|}
			\hline
Длина строки&ЛевМатр&ДамЛевМатр&РекДамЛевМатр \\
\hline
0&	0&	0&	0,001\\
\hline
10&	0,003&	0,003&	0,006\\
\hline
20&	0,009&	0,01&	0,017\\
\hline
30&	0,018&	0,022&	0,041\\
\hline
40&	0,031&	0,04&	0,07\\
\hline
50&	0,049&	0,064&	0,108\\
\hline
60&	0,068&	0,087&	0,154\\
\hline
70&	0,092&	0,122&	0,209\\
\hline
80&	0,126&	0,155&	0,27\\
\hline
90&	0,156&	0,202&	0,342\\
\hline
100&	0,192&	0,246&	0,422\\
\hline
		\end{tabular}
	\end{center}
\end{table}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{"inc/img/Снимок экрана 2022-10-22 154429"}
	\caption{Зависимость времени выполнения реализаций алгоритмов от длины строки}
	\label{fig:--2022-09-25-200448}
\end{figure}
\begin{table}[H]
	\begin{center}
		\caption{\label{tab:time2}Результаты замеров времени выполнения реализации рекурсивного алгоритма поиска расстояния Дамерау-Левенштейна}
		\begin{tabular}{|c|c|}
			\hline
			Длина строки&РекДамЛев \\
			\hline
			0&	0,01\\
			\hline
			1&	0\\
			\hline
			2&	0\\
			\hline
			3&	0\\
			\hline
			4&	0,02\\
			\hline
			5&	0,08\\
			\hline
			6&	0,39\\
			\hline
			7&	2,02\\
			\hline
			8& 10,6\\
			\hline
			9&	57,48\\
			\hline
		\end{tabular}
	\end{center}
\end{table}

 
\section{Использование памяти}

Нерекурсивные алгоритмы нахождения расстояний Дамерау-Левенштейна и Левенштейна не отличаются друг от друга с точки зрения использования памяти, поэтому достаточно рассмотреть лишь разницу рекурсивной и матричной реализаций алгоритмов поиска расстояния Дамерау-Левенштейна.

В C\# строки и матрицы являются ссылочными типами данных, поэтому память под них выделяется один раз в куче \cite{referencetypes}.

Пусть длина строки S1 -- n, длина строки S2 -- m, тогда затраты памяти на приведенные выше алгоритмы будут следующими.

Матричный алгоритм поиска расстояния Левенштейна: 
	\begin{itemize}
		\item ссылки на строки -- 16 байт;
		\item матрица -- ((m + 1) * (n + 1)) * sizeof(int);
		\item вспомогательные переменные --  5 * sizeof(int);
	\end{itemize}

Максимальная глубина стека вызовов при рекурсивной реализации равна сумме длин входящий строк. 

Рекурсивный алгоритм поиска расстояния (для каждого вызова):
\begin{itemize}
	\item ссылки на строки -- 16 байт;
	\item вспомогательные переменные --  6 * sizeof(int);
	\item адрес возврата.
\end{itemize}

Рекурсивный алгоритм поиска расстояния с использованием кеша (для каждого вызова) $V_{call}$:
	\begin{itemize}
		\item длины строк -- 2 * sizeof(int);
		\item вспомогательные переменные --  4 * sizeof(int);
		\item ссылки на строки -- 16 байт;
		\item ссылка на матрицу -- 8 байт;
		\item адрес возврата.
	\end{itemize}

Помимо самих вызовов еще требуется память для хранения самой матрицы:  
$(m * n) * \text{sizeof(int)}$. 

Итоговая память, затрачиваемая реализацией рекурсивного алгоритма поиска расстояния Дамерау-Левенштейна с использованием кеша:\\
$(m * n) * \text{sizeof(int)} + (m + n) * V_{call}$.

\section*{Вывод}
Рекурсивный алгоритм нахождения расстояния Дамерау-Левенштейна работает намного дольше итеративных реализаций. На словах длиной 10 символов, матричная реализация алгоритма нахождения расстояния Левенштейна превосходит по времени работы рекурсивную на несколько порядков.

Рекурсивный алгоритм с заполнением матрицы превосходит простой рекурсивный и работает в 1.5--2 раза дольше по сравнению с матричными алгоритмами. Алгоритм нахождения расстояния Дамерау-Левенштейна по времени выполнения сопоставим с алгоритмом нахождения расстояния Левенштейна. В нём добавлена дополнительная проверка, позволяющая находить ошибки пользователя, связанные с неверным порядком букв, в связи с чем он работает незначительно дольше, чем алгоритм нахождения расстояния Левенштейна.

Но по расходу памяти итеративные алгоритмы проигрывают рекурсивному: максимальный размер используемой памяти в них растёт как произведение длин строк, в то время как у рекурсивного алгоритма — как сумма длин строк.
