\chapter{АНАЛИТИЧЕСКАЯ ЧАСТЬ}


\section{Алгоритм Хаффмана}\label{data}

Основная идея заключается в кодировании переменной длины. Мы можем использовать тот факт, что некоторые символы в тексте встречаются чаще, чем другие (см. здесь), чтобы разработать алгоритм, который будет представлять ту же последовательность символов меньшим количеством битов. При кодировании переменной длины мы присваиваем символам переменное количество битов в зависимости от частоты их появления в данном тексте. В конечном итоге некоторые символы могут занимать всего 1 бит, а другие 2 бита, 3 или больше. Проблема с кодированием переменной длины заключается лишь в последующем декодировании последовательности.

Чтобы избежать неоднозначности при декодировании, мы должны гарантировать, что наше кодирование удовлетворяет такому понятию, как префиксное правило, которое в свою очередь подразумевает, что коды можно декодировать всего одним уникальным способом. Префиксное правило гарантирует, что ни один код не будет префиксом другого.

Построение кода Хаффмана сводится к построению соответствующего бинарного дерева по следующему алгоритму:

\begin{enumerate}
\item Составим список кодируемых символов, при этом будем рассматривать один символ как дерево, состоящее из одного элемента c весом, равным частоте появления символа в строке.
\item Из списка выберем два узла с наименьшим весом.
\item Сформируем новый узел с весом, равным сумме весов выбранных узлов, и присоединим к нему два выбранных узла в качестве детей.
\item Добавим к списку только что сформированный узел вместо двух объединенных узлов.
\item Если в списке больше одного узла, то повторим пункты со второго по пятый.
\end{enumerate}