

\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[14pt]{extsizes}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} 
\usepackage{pgfplots}
\usepackage{filecontents}
\usepackage{float}
\usepackage{indentfirst}
\usepackage{eucal}
\usepackage{enumitem}
%s\documentclass[openany]{book}
\frenchspacing

\usepackage{titlesec}
\titleformat{\section}
{\normalsize\bfseries}
{\thesection}
{1em}{}
\titlespacing*{\chapter}{0pt}{-30pt}{8pt}
\titlespacing*{\section}{\parindent}{*4}{*4}
\titlespacing*{\subsection}{\parindent}{*4}{*4}

\usepackage{indentfirst} % Красная строка

\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}

\usepackage{amsmath}


% Для листинга кода:
\lstset{ %
	language=c,                 % выбор языка для подсветки (здесь это С)
	basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
	numbers=left,               % где поставить нумерацию строк (слева\справа)
	numberstyle=\tiny,           % размер шрифта для номеров строк
	stepnumber=1,                   % размер шага между двумя номерами строк
	numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
	showspaces=false,            % показывать или нет пробелы специальными отступами
	showstringspaces=false,      % показывать или нет пробелы в строках
	showtabs=false,             % показывать или нет табуляцию в строках
	frame=single,              % рисовать рамку вокруг кода
	tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
	captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
	breaklines=true,           % автоматически переносить строки (да\нет)
	breakatwhitespace=false, % переносить строки только если есть пробел
	escapeinside={\#*}{*)}   % если нужно добавить комментарии в коде
}


\usepackage[left=2cm,right=2cm, top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
% Для измененных титулов глав:
\usepackage{titlesec, blindtext, color} % подключаем нужные пакеты
\definecolor{gray75}{gray}{0.75} % определяем цвет
\newcommand{\hsp}{\hspace{20pt}} % длина линии в 20pt
% titleformat определяет стиль
\titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Huge\bfseries}


% plot
\usepackage{pgfplots}
\usepackage{filecontents}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}

\begin{document}
	%\def\chaptername{} % убирает "Глава"
	\thispagestyle{empty}
	\begin{titlepage}
		\noindent \begin{minipage}{0.15\textwidth}
			\includegraphics[width=\linewidth]{b_logo}
		\end{minipage}
		\noindent\begin{minipage}{0.9\textwidth}\centering
			\textbf{Министерство науки и высшего образования Российской Федерации}\\
			\textbf{Федеральное государственное бюджетное образовательное учреждение высшего образования}\\
			\textbf{~~~«Московский государственный технический университет имени Н.Э.~Баумана}\\
			\textbf{(национальный исследовательский университет)»}\\
			\textbf{(МГТУ им. Н.Э.~Баумана)}
		\end{minipage}
		
		\noindent\rule{18cm}{3pt}
		\newline\newline
		\noindent ФАКУЛЬТЕТ $\underline{\text{«Информатика и системы управления»}}$ \newline\newline
		\noindent КАФЕДРА $\underline{\text{«Программное обеспечение ЭВМ и информационные технологии»}}$\newline\newline\newline\newline\newline
		
		\begin{center}
			\noindent\begin{minipage}{1.1\textwidth}\centering
				\Large\textbf{  Отчет по лабораторной работе №2}\newline
				\textbf{по дисциплине <<Функциональное и логическое}\newline
				\textbf{~~~программирование>>}\newline\newline
			\end{minipage}
		\end{center}
		
		\noindent\textbf{Тема} $\underline{\text{Определение функций пользователя}}$\newline\newline
		\noindent\textbf{Студент} $\underline{\text{Золотухин А. В.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}}$\newline\newline
		\noindent\textbf{Группа} $\underline{\text{ИУ7-64Б~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}}$\newline\newline
		\noindent\textbf{Оценка (баллы)} $\underline{\text{~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}}$\newline\newline
		\noindent\textbf{Преподаватели} $\underline{\text{Толпинская Н.Б., Строганов Ю. В.~~~~~~~~~~~~~~~~~~~~~~~~~~~~}}$\newline\newline\newline
		
		\begin{center}
			\vfill
			Москва~---~\the\year
			~г.
		\end{center}
	\end{titlepage}
	
	\chapter*{Теоретические вопросы}
	
	\section*{1. Базис Lisp}
	
	Базис -- это минимальный набор инструментов языка и стркутур данных, который позволяет решить любые задачи.
	
	
	Базис Lisp :
	
	\begin{itemize}
		\item атомы (представляются в памяти пятью указателями  --  name, value, function, property, package) и структуры (представляющиеся бинарными узлами);
		\item базовые (несколько) функций, функционалов и форм: встроенные — примитивные функции (atom, eq, cons, car, cdr); формы (quote, cond, lambda, eval); функционалы (apply, funcall).
	\end{itemize}
	
	Атомы:
	\begin{itemize} 
		\item символы (идентификаторы) – синтаксически – набор литер (букв и цифр), начинающихся с буквы;
		\item специальные символы – {T, Nil} (используются для обозначения логических констант);
		\item самоопределимые атомы – натуральные числа, дробные числа, вещественные числа, строки – последовательность символов, заключенных в двойные апострофы (например, “abc”);
	\end{itemize} 
	
	Более сложные данные – списки и точечные пары (структуры), которые строятся с помощью унифицированных структур – блоков памяти – бинарных узлов.
	
	Определения:
	
	Точечная пара ::= (<атом> . <атом>) | (<атом> . <точечная пара>) | (<точечная пара> . <атом>) | (<точечная пара> . <точечная пара>);
	
	Список ::= <пустой список> | <непустой список>, где 
	
	<пустой список> ::= () | Nil,
	
	<непустой список> ::= (<первый элемент> . <хвост>),
	
	<первый элемент> ::= <S-выражение>,
	
	S-выражение ::= <атом> | <точечная пара>,
	
	<хвост> ::= <список>.
	
	
	Функцией называется правило, по которому каждому значению одного или нескольких  аргументов ставится в соответствие конкретное значение результата. 
	
	%Функции всюду определены (то есть результат есть всегда), их аргументы и результаты -- S-выражения.
	
	Функционалом, или функцией высшего порядка называется функция, аргументом или  результатом которой является другая функция.
	
	Форма -- функция, которая особым образом обрабатывает свои аргументы или имеет переменное количество параметров.
	
	%Форма, или вычислимое выражение – это атом или список, который можно  вычислить и получить значение.
	
	
	
	\section*{2.Классификация функций}
	
	
	\begin{enumerate}
		\item Чистые  математические функции (имеют фиксированное количество аргументов, сначала выяисляются все аргументы, а только потом к ним применяется функция);
		\item Рекурсивные функции (основной способ выполнения повторных вычислений);
		\item Специальные функции, или формы (могут принимать произвольное количество аргументов, или аргументы могут обрабатываться по-разному);
		\item Псевдофункции (создают «эффект», например, вывод на экран);
		\item Функции с вариантами значений, из которых выбирается одно;
		\item Функции высших порядков, или функционалы --  функции, аргументом или  результатом которых является другая функция (используются для построения синтаксически управляемых программ);
	\end{enumerate}
	
	Классификаци базисных функций и функций ядра.
	
	\begin{enumerate}
		\item Селекторы: car и cdr (будут подробнее расссмотрены ниже).
		\item Конструкторы: cons и list (будут подробнее расссмотрены ниже).
		\item Предикаты -- <<логические>> функции, позволяющие определить структуру элемента:
		\begin{itemize}
			\item atom возвращает T, если значением её единственного аргумента является атом, иначе -- NIL;
			\item null возвращает T, если значение его аргумента -- NIL (пустой список), иначе -- NIL;
			\item listp возвращает T, если значением её аргумента является список, иначе -- NIL;
			\item consp возвращает T, если значением её аргумента является структура, представленная в виде списковой ячейки, иначе -- NIL. 
		\end{itemize}
		\item Функции сравнения (принимают два аргумента, перечислены по мере роста <<тщательности>> проверки):
		\begin{itemize}
			\item eq корректно сравнивает два символьных атома. Так как атомы не дублирутюся для данного сеанса работы, то фактически сравниваются соответсвующие указатели. 
			Возвращает T, когда: 1) значением одного из аргументов является атом, и одновременно 2) значения аргументов равны (идентичны). В ином случае значением функции eq является NIL. (eq  'ab 'Ab) => T, но (eq 1 2) => NIL.
			\item eql корректно сравнивает атомы и числа одинакового типа (синтетической формы записи). Например, (eql 1 1) вернет T, а (eql 1 1.0) -- Nil, так как целое значение 1 и значение с плавающей точкой 1.0 являются представителями различных классов;
			\item = корректно сравнивает только числа, причем числа могут быть разных типов. Например, и (= 1 1), и (= 1 1.0) вернет T;
			\item equal работает идентично eql, но в дополнение умеет корректно сравнивать списки (считая списки эквивалентными, если они рекурсивно, согласно тому же equal, имеют одинаковую структуру и содержимое; считая строки эквивалентными, если они содержат одинаковые знаки);
			\item equalp корректно сравнивает любые S-выражения. 
		\end{itemize}
	\end{enumerate}
	
	
	
	\section*{3. Способы создания функций}
	
	Определение функций пользователя в Lisp-е возможно двумя способами.
	
	
	\begin{itemize}
		\item Базисный способ  определения  функции - использование $\lambda$-выражения ($\lambda$-нотации). Так создаются функции без имени.
		
		$\lambda$-выражение: (lambda $\lambda$-список форма), 
		где $\lambda$-список --  это формальные параметры функции (список аргументов), а форма -- это тело функции.
		
		Вызов такой функции осуществляется следующим способом: ($\lambda$-выражение последовательность\_форм), 
		где последовательность\_форм -- это фактические параметры.
		
		Вычисление функций без имени может быть также выполнено с использованием функционала apply: (apply $\lambda$-выражение последовательность\_форм), где последовательность\_форм -- это список фактических параметров; или с использованием функционала funcall: (funcall $\lambda$-выражение последовательность\_форм), где последовательность\_форм -- это фактические параметры.
		
		Функционал apply является обычной функцией с двумя  вычисляемыми аргументами, обращение к ней имеет вид: (apply F L), где F – функциональный аргумент и L -- список, рассматриваемый как список фактических параметров для F. Значение функционала -- результат применения F к этим фактическим параметрам.
		
		Функционал funcall – особая функция с вычисляемыми аргументами, обращение к ней: (funcall F e1 … en), n $\geqslant 0$. Её   действие аналогично apply, отличие состоит в том, что аргументы  применяемой функции F задаются не списком, а по отдельности. 
		
		funcall используется тогда, когда во время написания кода количество аргументов известно, apply -- когда неизвестно.
		
		\item Другой способ определения функции -- использование макро-определения defun: 
		
		(defun имя\_функции $\lambda$-выражение), 
		
		или  в облегченной форме:
		
		(defun имя\_функции $(x_1, x_2, ..., x_k)$ форма), 
		где $(x_1, x_2, ..., x_k)$ -- это  список аргументов.
		
		В качестве имени функции выступает символьный атом. 
		Вызов именованной функции осуществляется следующим образом: (имя\_функции последовательность\_форм), 
		где последовательность\_форм -- это фактические параметры.
		Также для ее вызова можно воспользоваться рассмотренными выше функционалами funcall (например, (foo 1 2 3) === (funcall \#'foo 1 2 3)) и apply (например, (apply \#'plot plot-data), где plot-data - список, хранящий аргументы).
		
	\end{itemize}
	
	$\lambda$-определение более эффективно, особенно при повторных вычислениях. 
	
	Параметры функции, переданные при вызове, будут связаны с переменными в списке параметров из объявления функции. Еще один способ связывания формальных параметров с фактическими -- использование функции let:
	
	(let ((x1 p1) (x2 p2) ... (xk pk))  e),
	
	где xi -- формальные параметры, pi -- фактические параметры (могут быть формами), e -- форма (что делать).
	
	\section*{4. Функции Car и Cdr}
	
	Функции car и cdr переходят по соответсвующему указателю аргумента (бинарного узла).
	
	Функция car от одного аргумента возвращает первый элемент списка, являющегося значением её аргумента. 
	
	Функция cdr возвращает хвост списка, являющегося значением её единственного аргумента (хвостом, или остатком списка является список  без своего первого элемента).  
	
	Современные диалекты  Лиспа обычно допускают для функций car и cdr мнемоничные синонимичные названия: first и rest соответственно.
	
	\section*{5. Назначение и отличие в работе Cons и List}
	
	cons принимает 2 указателя на любые S-выражения и возвращает новую cons-ячейку (списковую ячейку), содержащую 2 значения. Если второе значение не NIL и не другая cons-ячейка, то ячейка печатается как два значения в скобках, разделённые точкой (так называемая точечная пара). Иначе, по сути, эта функция включает значение первого аргумента в начало списка, являющегося значением второго аргумента. 
	
	Функция list, составляющая список из значений своих аргументов (у которого голова -- это первый аргумент, хвост -- все остальные аргументы), создает столько списковых ячеек, сколько аргументов ей было передано. Эта функция относится к особым, поскольку у неё может быть произвольное число аргументов, но при этом все аргументы вычисляются
	
	Итак, отличия: cons является базисной, list -- нет; cons имеет  фиксированное количество аргументов (два), list -- произвольное; cons создает точечную пару или список (в зависимости от второго аргумента), list -- список; в отличие от функции cons, результат функции list симметричен относительно аргументов: (list '(А) '(В)) => ((А)(В)), но (cons '(А) '(В)) => ((А) В).
	
	cons эффективнее list, list определяется с помощью cons.
		
	\chapter*{Практические задания}	
	
	
	\bibliographystyle{utf8gost705u}  % стилевой файл для оформления по ГОСТу
	
	\bibliography{51-biblio}          % имя библиографической базы (bib-файла)
	
	
\end{document}